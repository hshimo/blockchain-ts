import { ITransaction } from "./blockchain";
import { multisigInfo, ETransactionType } from "./interface";
import sha256 from "sha256";
import Cypher from "./crypto/cypher";

import sha1 from "sha1";
import BlockChainApp from "./blockchainApp";
import { IEvents, excuteEvent } from "../util";
const Buffer = require("buffer/").Buffer;
var aes256 = require("aes256");
const sss = require("shamirs-secret-sharing");

export enum type {
  MAKE = "multisig-make",
  TRAN = "multisig-tran",
  APPROVE = "multisig-approve",
  MULTISIG = "multisig"
}

interface multisigData {
  myShare: string;
  shares: Array<string>;
  threshold: number;
  pubKey: string;
  encryptPhrase: string;
  isOwner?: boolean;
}

interface ITranMultisig {
  opt: type;
  shares: any;
  info: any;
}

export default class Multisig {
  multiSig: { [key: string]: multisigData } = {};
  address: string;
  b: BlockChainApp;
  cypher: Cypher;
  private onMultisigTran: IEvents = {};
  private onMultisigTranDone: IEvents = {};
  events = {
    onMultisigTran: this.onMultisigTran,
    onMultisigTranDone: this.onMultisigTranDone
  };

  constructor(blockchain: BlockChainApp) {
    this.b = blockchain;
    console.log("address", this.b.address);
    this.address = this.b.address;
    //秘密鍵と公開鍵を生成
    this.cypher = new Cypher();
  }

  //通信などにより得られた命令に対する処理
  responder(tran: ITransaction) {
    const data = tran.data;
    console.log("responder", { data });
    if (data.type === ETransactionType.multisig) {
      const tranMultisig: ITranMultisig = data.payload;
      switch (tranMultisig.opt) {
        case type.MAKE:
          {
            //トランザクションからマルチシグの情報を取得
            this.getMultiSigKey(tranMultisig.shares, tranMultisig.info);
          }
          break;
        case type.TRAN:
          {
            //イベントの準備
            this.onMultiSigTransaction(tranMultisig.info);
          }
          break;
        case type.APPROVE:
          {
            this.onApproveMultiSig(tranMultisig.info);
          }
          break;
      }
    }
  }

  //マルチシグのアドレスを生成
  makeNewMultiSigAddress(
    friendsPubKeyAes: Array<string>, //共有者の情報
    vote: number, //しきい値
    amount: number //金額
  ) {
    //次に使うaeskeyを生成
    const aesKey = sha1(Math.random().toString()).toString();

    //aeskeyで秘密鍵を暗号化
    const encryptPhrase: string = aes256.encrypt(aesKey, this.cypher.phrase);

    //シャミアの秘密分散ライブラリでaeskeyをシェア化
    const shareKeys: any[] = sss.split(Buffer.from(aesKey), {
      shares: friendsPubKeyAes.length + 1,
      threshold: vote
    });

    console.log({ shareKeys });

    //マルチシグアドレスを導出
    const address = sha256(this.cypher.pubKey);
    const shares: { [key: string]: string } = {};

    //シェアの共有者にシェアを配布
    friendsPubKeyAes.forEach((aes, i) => {
      const pubKey = aes256.decrypt("format", aes);
      const id = sha256(pubKey);
      console.log("makeNewMultiSigAddress sharekey", shareKeys[i]);
      //共有者の公開鍵でシェアを暗号化
      shares[id] = this.cypher.encrypt(shareKeys[i], pubKey);
    });
    console.log({ shares });

    //自身にシェアを一つ割当
    const myShare = shareKeys[shareKeys.length - 1];

    //マルチシグの情報を保管
    this.multiSig[address] = {
      myShare,
      threshold: vote,
      isOwner: false,
      pubKey: this.cypher.pubKey,
      encryptPhrase,
      shares: []
    };
    this.multiSig[address].shares.push(myShare);

    //ブロックチェーンに載せるマルチシグ情報
    const info: multisigInfo = {
      multisigPubKey: this.cypher.pubKey,
      multisigAddress: address,
      encryptPhrase,
      threshold: vote
    };

    //トランザクションを生成
    const tran = this.b.newTransaction(this.b.address, address, amount, {
      type: ETransactionType.multisig,
      payload: { opt: type.MAKE, shares, info }
    });
    console.log("makeNewMultiSigAddress done", { tran });
    return tran;
  }

  //トランザクションからマルチシグの情報を取得
  private getMultiSigKey(
    shares: { [key: string]: string },
    info: multisigInfo
  ) {
    console.log("getMultiSigKey");
    if (info.encryptPhrase && Object.keys(shares).includes(this.address)) {
      console.log("getMultiSigKey start");

      //シェアキーの公開鍵暗号を秘密鍵で解除
      const key = this.cypher.decrypt(shares[this.address]);

      console.log("getMultiSigKey get my key", key);

      //マルチシグ情報を保存
      this.multiSig[info.multisigAddress] = {
        myShare: key,
        isOwner: false,
        threshold: info.threshold,
        pubKey: info.multisigPubKey,
        encryptPhrase: info.encryptPhrase,
        shares: []
      };
    }
  }

  //マルチシグのトランザクションを生成
  makeMultiSigTransaction(multisigAddress: string) {
    console.log("makeMultiSigTransaction start");

    //マルチシグアドレスの情報を自分が持っているのか
    const data = this.multiSig[multisigAddress];
    if (!data) return;
    const multisigPubKey = data.pubKey;

    //自分の持っているシェアキーを公開鍵で暗号化
    const shareKeyRsa = this.cypher.encrypt(data.myShare);
    crypto
      .publicEncrypt(this.b.cypher.pubKey, Buffer.from(data.myShare, "base64"))
      .toString("base64");

    //ブロックチェーンに載せる情報
    const info: multisigInfo = {
      ownerPubKey: this.b.cypher.pubKey,
      multisigPubKey,
      multisigAddress,
      sharePubKeyRsa: shareKeyRsa,
      threshold: data.threshold
    };
    //マルチシグ情報にトランザクション実行者フラグを立てる
    data.isOwner = true;

    //マルチシグアドレスの残高を取得
    const amount = this.b.nowAmount(multisigAddress);
    console.log("multisig tran", { amount });

    //トランザクションを生成
    const tran = this.b.newTransaction(this.b.address, multisigAddress, 0, {
      type: ETransactionType.multisig,
      payload: {
        opt: type.TRAN,
        amount,
        info
      }
    });
    console.log("makeMultiSigTransaction done", { tran });
    return tran;
  }

  //イベントコールバックに任せる
  private onMultiSigTransaction(info: multisigInfo) {
    if (Object.keys(this.multiSig).includes(info.multisigAddress)) {
      console.log("onMultisigTran");
      excuteEvent(this.onMultisigTran, info);
    }
  }

  //マルチシグの承認
  approveMultiSig(info: multisigInfo) {
    console.log("approveMultiSig");
    if (info.ownerPubKey) {
      //マルチシグの情報があるかを調べる
      if (Object.keys(this.multiSig).includes(info.multisigAddress)) {
        console.log("approveMultiSig start");

        //シェアキーを取り出す
        const key = this.multiSig[info.multisigAddress].myShare;
        //シェアキーをマルチシグトランザクション実行者の公開鍵で暗号化
        const shareKeyRsa = crypto
          .publicEncrypt(info.ownerPubKey, Buffer.from(key, "base64"))
          .toString("base64");
        info.sharePubKeyRsa = shareKeyRsa;
        //トランザクションを生成
        const tran = this.b.newTransaction(
          this.b.address,
          info.multisigAddress,
          0,
          {
            type: ETransactionType.multisig,
            payload: {
              opt: type.APPROVE,
              info: info
            }
          }
        );
        console.log("approveMultiSig done", { tran });
        return tran;
      }
    }
  }

  //マルチシグトランザクション実行者の関数
  private onApproveMultiSig(info: multisigInfo) {
    if (
      info.sharePubKeyRsa &&
      info.ownerPubKey === this.b.cypher.pubKey &&
      Object.keys(this.multiSig).includes(info.multisigAddress)
    ) {
      console.log("type.APPROVE");
      const shares = this.multiSig[info.multisigAddress].shares;

      //シェアキーの公開鍵暗号を自身の秘密鍵で解除
      const shareKey = crypto.privateDecrypt(
        this.b.cypher.secKey,
        Buffer.from(info.sharePubKeyRsa, "base64")
      );

      //新しいシェアキーなら保存する。
      if (!shares.includes(shareKey)) {
        console.log("add sharekey", { shareKey });
        shares.push(shareKey);
      }

      //シェアキーの数がしきい値を超えればトランザクションを承認
      if (shares.length >= info.threshold) {
        console.log("verify multisig", { shares });
        //トランザクションの承認関数
        this.verifyMultiSig(info, shares);
      }
    }
  }

  //トランザクションの承認
  private verifyMultiSig(info: multisigInfo, shares: Array<any>) {
    console.log("verifyMultiSig start", { shares });
    //シャミアのシェアキーからシークレットを復号化
    const recovered = sss.combine(shares).toString();
    console.log({ recovered });

    //aes暗号化されたシークレットキーを取り出す。
    const encryptedPhrase = this.multiSig[info.multisigAddress].encryptPhrase;
    //aes暗号を復号化
    const phrase = aes256.decrypt(recovered, encryptedPhrase);
    console.log({ phrase });
    const cypher = new Cypher(phrase);
    const address = info.multisigAddress;
    //マルチシグアドレスの残高を取得
    const amount = this.b.nowAmount(address);
    //残高があればトランザクションを実行
    if (amount > 0) {
      const tran = this.b.newTransaction(
        address,
        this.b.address,
        amount,
        { type: ETransactionType.transaction, payload: "verifymultisig" },
        cypher
      );
      console.log("verifyMultiSig done", this.b.address, { tran });
      excuteEvent(this.onMultisigTranDone);
      return tran;
    }
  }
}
