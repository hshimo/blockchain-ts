"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decryptPassphraseWithPassword = exports.encryptPassphraseWithPassword = exports.decryptMessageWithPassphrase = exports.encryptMessageWithPassphrase = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

var _buffer = require("./buffer");

var _convert = require("./convert");

var _keys = require("./keys");

var _nacl = require("./nacl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Copyright Â© 2018 Lisk Foundation
 *
 * See the LICENSE file at the top-level directory of this distribution
 * for licensing information.
 *
 * Unless otherwise agreed in a custom licensing agreement with the Lisk Foundation,
 * no part of this software, including this file, may be copied, modified,
 * propagated, or distributed except according to the terms contained in the
 * LICENSE file.
 *
 * Removal or modification of this copyright notice is prohibited.
 *
 */
var PBKDF2_ITERATIONS = 1e6;
var PBKDF2_KEYLEN = 32;
var PBKDF2_HASH_FUNCTION = "sha256";
var ENCRYPTION_VERSION = "1";

var encryptMessageWithPassphrase = function encryptMessageWithPassphrase(message, passphrase, recipientPublicKey) {
  var _getPrivateAndPublicK = (0, _keys.getPrivateAndPublicKeyBytesFromPassphrase)(passphrase),
      senderPrivateKeyBytes = _getPrivateAndPublicK.privateKeyBytes,
      senderPublicKeyBytes = _getPrivateAndPublicK.publicKeyBytes;

  var convertedPrivateKey = Buffer.from((0, _convert.convertPrivateKeyEd2Curve)(senderPrivateKeyBytes));
  var convertedSenderPublicKey = (0, _buffer.bufferToHex)(senderPublicKeyBytes);
  var recipientPublicKeyBytes = (0, _buffer.hexToBuffer)(recipientPublicKey);
  var messageInBytes = Buffer.from(message, "utf8");
  var nonceSize = 24;
  var nonce = (0, _nacl.getRandomBytes)(nonceSize);
  var publicKeyUint8Array = (0, _convert.convertPublicKeyEd2Curve)(recipientPublicKeyBytes); // This cannot be reproduced, but external library have type union with null

  if (publicKeyUint8Array === null) {
    throw new Error("given public key is not a valid Ed25519 public key");
  }

  var convertedPublicKey = Buffer.from(publicKeyUint8Array);
  var cipherBytes = (0, _nacl.box)(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);
  var nonceHex = (0, _buffer.bufferToHex)(nonce);
  var encryptedMessage = (0, _buffer.bufferToHex)(cipherBytes);
  return {
    nonce: nonceHex,
    encryptedMessage: encryptedMessage,
    senderPublickey: convertedSenderPublicKey
  };
};

exports.encryptMessageWithPassphrase = encryptMessageWithPassphrase;

var decryptMessageWithPassphrase = function decryptMessageWithPassphrase(cipherHex, nonce, passphrase, senderPublicKey) {
  var _getPrivateAndPublicK2 = (0, _keys.getPrivateAndPublicKeyBytesFromPassphrase)(passphrase),
      recipientPrivateKeyBytes = _getPrivateAndPublicK2.privateKeyBytes;

  var convertedPrivateKey = Buffer.from((0, _convert.convertPrivateKeyEd2Curve)(recipientPrivateKeyBytes));
  var senderPublicKeyBytes = (0, _buffer.hexToBuffer)(senderPublicKey);
  var cipherBytes = (0, _buffer.hexToBuffer)(cipherHex);
  var nonceBytes = (0, _buffer.hexToBuffer)(nonce);
  var publicKeyUint8Array = (0, _convert.convertPublicKeyEd2Curve)(senderPublicKeyBytes);

  if (!publicKeyUint8Array) {
    throw new Error("given public key is not a valid Ed25519 public key");
  }

  var convertedPublicKey = Buffer.from(publicKeyUint8Array);

  try {
    var decoded = (0, _nacl.openBox)(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);
    return Buffer.from(decoded).toString();
  } catch (error) {
    if (error.message.match(/bad nonce size|nonce must be a buffer of size crypto_box_NONCEBYTES/)) {
      throw new Error("Expected nonce to be 24 bytes.");
    }

    throw new Error("Something went wrong during decryption. Is this the full encrypted message?");
  }
};

exports.decryptMessageWithPassphrase = decryptMessageWithPassphrase;

var getKeyFromPassword = function getKeyFromPassword(password, salt, iterations) {
  return _crypto.default.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);
};

var encryptAES256GCMWithPassword = function encryptAES256GCMWithPassword(plainText, password) {
  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PBKDF2_ITERATIONS;
  var IV_BUFFER_SIZE = 12;
  var SALT_BUFFER_SIZE = 16;

  var iv = _crypto.default.randomBytes(IV_BUFFER_SIZE);

  var salt = _crypto.default.randomBytes(SALT_BUFFER_SIZE);

  var key = getKeyFromPassword(password, salt, iterations);

  var cipher = _crypto.default.createCipheriv("aes-256-gcm", key, iv);

  var firstBlock = cipher.update(plainText, "utf8");
  var encrypted = Buffer.concat([firstBlock, cipher.final()]);
  var tag = cipher.getAuthTag();
  return {
    iterations: iterations,
    cipherText: encrypted.toString("hex"),
    iv: iv.toString("hex"),
    salt: salt.toString("hex"),
    tag: tag.toString("hex"),
    version: ENCRYPTION_VERSION
  };
};

var getTagBuffer = function getTagBuffer(tag) {
  var TAG_BUFFER_SIZE = 16;
  var tagBuffer = (0, _buffer.hexToBuffer)(tag, "Tag");

  if (tagBuffer.length !== TAG_BUFFER_SIZE) {
    throw new Error("Tag must be 16 bytes.");
  }

  return tagBuffer;
};

var decryptAES256GCMWithPassword = function decryptAES256GCMWithPassword(encryptedPassphrase, password) {
  var _encryptedPassphrase$ = encryptedPassphrase.iterations,
      iterations = _encryptedPassphrase$ === void 0 ? PBKDF2_ITERATIONS : _encryptedPassphrase$,
      cipherText = encryptedPassphrase.cipherText,
      iv = encryptedPassphrase.iv,
      salt = encryptedPassphrase.salt,
      tag = encryptedPassphrase.tag;
  var tagBuffer = getTagBuffer(tag);
  var key = getKeyFromPassword(password, (0, _buffer.hexToBuffer)(salt, "Salt"), iterations);

  var decipher = _crypto.default.createDecipheriv("aes-256-gcm", key, (0, _buffer.hexToBuffer)(iv, "IV"));

  decipher.setAuthTag(tagBuffer);
  var firstBlock = decipher.update((0, _buffer.hexToBuffer)(cipherText, "Cipher text"));
  var decrypted = Buffer.concat([firstBlock, decipher.final()]);
  return decrypted.toString();
};

var encryptPassphraseWithPassword = encryptAES256GCMWithPassword;
exports.encryptPassphraseWithPassword = encryptPassphraseWithPassword;
var decryptPassphraseWithPassword = decryptAES256GCMWithPassword;
exports.decryptPassphraseWithPassword = decryptPassphraseWithPassword;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ibG9ja2NoYWluL2NyeXB0by9lbmNyeXB0LnRzIl0sIm5hbWVzIjpbIlBCS0RGMl9JVEVSQVRJT05TIiwiUEJLREYyX0tFWUxFTiIsIlBCS0RGMl9IQVNIX0ZVTkNUSU9OIiwiRU5DUllQVElPTl9WRVJTSU9OIiwiZW5jcnlwdE1lc3NhZ2VXaXRoUGFzc3BocmFzZSIsIm1lc3NhZ2UiLCJwYXNzcGhyYXNlIiwicmVjaXBpZW50UHVibGljS2V5Iiwic2VuZGVyUHJpdmF0ZUtleUJ5dGVzIiwicHJpdmF0ZUtleUJ5dGVzIiwic2VuZGVyUHVibGljS2V5Qnl0ZXMiLCJwdWJsaWNLZXlCeXRlcyIsImNvbnZlcnRlZFByaXZhdGVLZXkiLCJCdWZmZXIiLCJmcm9tIiwiY29udmVydGVkU2VuZGVyUHVibGljS2V5IiwicmVjaXBpZW50UHVibGljS2V5Qnl0ZXMiLCJtZXNzYWdlSW5CeXRlcyIsIm5vbmNlU2l6ZSIsIm5vbmNlIiwicHVibGljS2V5VWludDhBcnJheSIsIkVycm9yIiwiY29udmVydGVkUHVibGljS2V5IiwiY2lwaGVyQnl0ZXMiLCJub25jZUhleCIsImVuY3J5cHRlZE1lc3NhZ2UiLCJzZW5kZXJQdWJsaWNrZXkiLCJkZWNyeXB0TWVzc2FnZVdpdGhQYXNzcGhyYXNlIiwiY2lwaGVySGV4Iiwic2VuZGVyUHVibGljS2V5IiwicmVjaXBpZW50UHJpdmF0ZUtleUJ5dGVzIiwibm9uY2VCeXRlcyIsImRlY29kZWQiLCJ0b1N0cmluZyIsImVycm9yIiwibWF0Y2giLCJnZXRLZXlGcm9tUGFzc3dvcmQiLCJwYXNzd29yZCIsInNhbHQiLCJpdGVyYXRpb25zIiwiY3J5cHRvIiwicGJrZGYyU3luYyIsImVuY3J5cHRBRVMyNTZHQ01XaXRoUGFzc3dvcmQiLCJwbGFpblRleHQiLCJJVl9CVUZGRVJfU0laRSIsIlNBTFRfQlVGRkVSX1NJWkUiLCJpdiIsInJhbmRvbUJ5dGVzIiwia2V5IiwiY2lwaGVyIiwiY3JlYXRlQ2lwaGVyaXYiLCJmaXJzdEJsb2NrIiwidXBkYXRlIiwiZW5jcnlwdGVkIiwiY29uY2F0IiwiZmluYWwiLCJ0YWciLCJnZXRBdXRoVGFnIiwiY2lwaGVyVGV4dCIsInZlcnNpb24iLCJnZXRUYWdCdWZmZXIiLCJUQUdfQlVGRkVSX1NJWkUiLCJ0YWdCdWZmZXIiLCJsZW5ndGgiLCJkZWNyeXB0QUVTMjU2R0NNV2l0aFBhc3N3b3JkIiwiZW5jcnlwdGVkUGFzc3BocmFzZSIsImRlY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXJpdiIsInNldEF1dGhUYWciLCJkZWNyeXB0ZWQiLCJlbmNyeXB0UGFzc3BocmFzZVdpdGhQYXNzd29yZCIsImRlY3J5cHRQYXNzcGhyYXNlV2l0aFBhc3N3b3JkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFsQkE7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLElBQU1BLGlCQUFpQixHQUFHLEdBQTFCO0FBQ0EsSUFBTUMsYUFBYSxHQUFHLEVBQXRCO0FBQ0EsSUFBTUMsb0JBQW9CLEdBQUcsUUFBN0I7QUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxHQUEzQjs7QUFRTyxJQUFNQyw0QkFBNEIsR0FBRyxTQUEvQkEsNEJBQStCLENBQzFDQyxPQUQwQyxFQUUxQ0MsVUFGMEMsRUFHMUNDLGtCQUgwQyxFQUlaO0FBQUEsOEJBSTFCLHFEQUEwQ0QsVUFBMUMsQ0FKMEI7QUFBQSxNQUVYRSxxQkFGVyx5QkFFNUJDLGVBRjRCO0FBQUEsTUFHWkMsb0JBSFkseUJBRzVCQyxjQUg0Qjs7QUFLOUIsTUFBTUMsbUJBQW1CLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBUCxDQUMxQix3Q0FBMEJOLHFCQUExQixDQUQwQixDQUE1QjtBQUlBLE1BQU1PLHdCQUF3QixHQUFHLHlCQUFZTCxvQkFBWixDQUFqQztBQUVBLE1BQU1NLHVCQUF1QixHQUFHLHlCQUFZVCxrQkFBWixDQUFoQztBQUNBLE1BQU1VLGNBQWMsR0FBR0osTUFBTSxDQUFDQyxJQUFQLENBQVlULE9BQVosRUFBcUIsTUFBckIs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SUFBTTZCLDZCQUE2QixHQUFHUCw0QkFBdEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IMKpIDIwMTggTGlzayBGb3VuZGF0aW9uXG4gKlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgYXQgdGhlIHRvcC1sZXZlbCBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb25cbiAqIGZvciBsaWNlbnNpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVW5sZXNzIG90aGVyd2lzZSBhZ3JlZWQgaW4gYSBjdXN0b20gbGljZW5zaW5nIGFncmVlbWVudCB3aXRoIHRoZSBMaXNrIEZvdW5kYXRpb24sXG4gKiBubyBwYXJ0IG9mIHRoaXMgc29mdHdhcmUsIGluY2x1ZGluZyB0aGlzIGZpbGUsIG1heSBiZSBjb3BpZWQsIG1vZGlmaWVkLFxuICogcHJvcGFnYXRlZCwgb3IgZGlzdHJpYnV0ZWQgZXhjZXB0IGFjY29yZGluZyB0byB0aGUgdGVybXMgY29udGFpbmVkIGluIHRoZVxuICogTElDRU5TRSBmaWxlLlxuICpcbiAqIFJlbW92YWwgb3IgbW9kaWZpY2F0aW9uIG9mIHRoaXMgY29weXJpZ2h0IG5vdGljZSBpcyBwcm9oaWJpdGVkLlxuICpcbiAqL1xuaW1wb3J0IGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBidWZmZXJUb0hleCwgaGV4VG9CdWZmZXIgfSBmcm9tIFwiLi9idWZmZXJcIjtcbmltcG9ydCB7IGNvbnZlcnRQcml2YXRlS2V5RWQyQ3VydmUsIGNvbnZlcnRQdWJsaWNLZXlFZDJDdXJ2ZSB9IGZyb20gXCIuL2NvbnZlcnRcIjtcbmltcG9ydCB7IGdldFByaXZhdGVBbmRQdWJsaWNLZXlCeXRlc0Zyb21QYXNzcGhyYXNlIH0gZnJvbSBcIi4va2V5c1wiO1xuaW1wb3J0IHsgYm94LCBnZXRSYW5kb21CeXRlcywgb3BlbkJveCB9IGZyb20gXCIuL25hY2xcIjtcblxuY29uc3QgUEJLREYyX0lURVJBVElPTlMgPSAxZTY7XG5jb25zdCBQQktERjJfS0VZTEVOID0gMzI7XG5jb25zdCBQQktERjJfSEFTSF9GVU5DVElPTiA9IFwic2hhMjU2XCI7XG5jb25zdCBFTkNSWVBUSU9OX1ZFUlNJT04gPSBcIjFcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWRNZXNzYWdlV2l0aE5vbmNlIHtcbiAgcmVhZG9ubHkgZW5jcnlwdGVkTWVzc2FnZTogc3RyaW5nO1xuICByZWFkb25seSBub25jZTogc3RyaW5nO1xuICByZWFkb25seSBzZW5kZXJQdWJsaWNrZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGVuY3J5cHRNZXNzYWdlV2l0aFBhc3NwaHJhc2UgPSAoXG4gIG1lc3NhZ2U6IHN0cmluZyxcbiAgcGFzc3BocmFzZTogc3RyaW5nLFxuICByZWNpcGllbnRQdWJsaWNLZXk6IHN0cmluZ1xuKTogRW5jcnlwdGVkTWVzc2FnZVdpdGhOb25jZSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwcml2YXRlS2V5Qnl0ZXM6IHNlbmRlclByaXZhdGVLZXlCeXRlcyxcbiAgICBwdWJsaWNLZXlCeXRlczogc2VuZGVyUHVibGljS2V5Qnl0ZXNcbiAgfSA9IGdldFByaXZhdGVBbmRQdWJsaWNLZXlCeXRlc0Zyb21QYXNzcGhyYXNlKHBhc3NwaHJhc2UpO1xuICBjb25zdCBjb252ZXJ0ZWRQcml2YXRlS2V5ID0gQnVmZmVyLmZyb20oXG4gICAgY29udmVydFByaXZhdGVLZXlFZDJDdXJ2ZShzZW5kZXJQcml2YXRlS2V5Qnl0ZXMpXG4gICk7XG5cbiAgY29uc3QgY29udmVydGVkU2VuZGVyUHVibGljS2V5ID0gYnVmZmVyVG9IZXgoc2VuZGVyUHVibGljS2V5Qnl0ZXMpO1xuXG4gIGNvbnN0IHJlY2lwaWVudFB1YmxpY0tleUJ5dGVzID0gaGV4VG9CdWZmZXIocmVjaXBpZW50UHVibGljS2V5KTtcbiAgY29uc3QgbWVzc2FnZUluQnl0ZXMgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCBcInV0ZjhcIik7XG4gIGNvbnN0IG5vbmNlU2l6ZSA9IDI0O1xuICBjb25zdCBub25jZSA9IGdldFJhbmRvbUJ5dGVzKG5vbmNlU2l6ZSk7XG4gIGNvbnN0IHB1YmxpY0tleVVpbnQ4QXJyYXkgPSBjb252ZXJ0UHVibGljS2V5RWQyQ3VydmUocmVjaXBpZW50UHVibGljS2V5Qnl0ZXMpO1xuXG4gIC8vIFRoaXMgY2Fubm90IGJlIHJlcHJvZHVjZWQsIGJ1dCBleHRlcm5hbCBsaWJyYXJ5IGhhdmUgdHlwZSB1bmlvbiB3aXRoIG51bGxcbiAgaWYgKHB1YmxpY0tleVVpbnQ4QXJyYXkgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnaXZlbiBwdWJsaWMga2V5IGlzIG5vdCBhIHZhbGlkIEVkMjU1MTkgcHVibGljIGtleVwiKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnZlcnRlZFB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHB1YmxpY0tleVVpbnQ4QXJyYXkpO1xuXG4gIGNvbnN0IGNpcGhlckJ5dGVzID0gYm94KFxuICAgIG1lc3NhZ2VJbkJ5dGVzLFxuICAgIG5vbmNlLFxuICAgIGNvbnZlcnRlZFB1YmxpY0tleSxcbiAgICBjb252ZXJ0ZWRQcml2YXRlS2V5XG4gICk7XG5cbiAgY29uc3Qgbm9uY2VIZXggPSBidWZmZXJUb0hleChub25jZSk7XG4gIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBidWZmZXJUb0hleChjaXBoZXJCeXRlcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBub25jZTogbm9uY2VIZXgsXG4gICAgZW5jcnlwdGVkTWVzc2FnZSxcbiAgICBzZW5kZXJQdWJsaWNrZXk6IGNvbnZlcnRlZFNlbmRlclB1YmxpY0tleVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY3J5cHRNZXNzYWdlV2l0aFBhc3NwaHJhc2UgPSAoXG4gIGNpcGhlckhleDogc3RyaW5nLFxuICBub25jZTogc3RyaW5nLFxuICBwYXNzcGhyYXNlOiBzdHJpbmcsXG4gIHNlbmRlclB1YmxpY0tleTogc3RyaW5nXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB7XG4gICAgcHJpdmF0ZUtleUJ5dGVzOiByZWNpcGllbnRQcml2YXRlS2V5Qnl0ZXNcbiAgfSA9IGdldFByaXZhdGVBbmRQdWJsaWNLZXlCeXRlc0Zyb21QYXNzcGhyYXNlKHBhc3NwaHJhc2UpO1xuICBjb25zdCBjb252ZXJ0ZWRQcml2YXRlS2V5ID0gQnVmZmVyLmZyb20oXG4gICAgY29udmVydFByaXZhdGVLZXlFZDJDdXJ2ZShyZWNpcGllbnRQcml2YXRlS2V5Qnl0ZXMpXG4gICk7XG4gIGNvbnN0IHNlbmRlclB1YmxpY0tleUJ5dGVzID0gaGV4VG9CdWZmZXIoc2VuZGVyUHVibGljS2V5KTtcbiAgY29uc3QgY2lwaGVyQnl0ZXMgPSBoZXhUb0J1ZmZlcihjaXBoZXJIZXgpO1xuICBjb25zdCBub25jZUJ5dGVzID0gaGV4VG9CdWZmZXIobm9uY2UpO1xuXG4gIGNvbnN0IHB1YmxpY0tleVVpbnQ4QXJyYXkgPSBjb252ZXJ0UHVibGljS2V5RWQyQ3VydmUoc2VuZGVyUHVibGljS2V5Qnl0ZXMpO1xuXG4gIGlmICghcHVibGljS2V5VWludDhBcnJheSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdpdmVuIHB1YmxpYyBrZXkgaXMgbm90IGEgdmFsaWQgRWQyNTUxOSBwdWJsaWMga2V5XCIpO1xuICB9XG5cbiAgY29uc3QgY29udmVydGVkUHVibGljS2V5ID0gQnVmZmVyLmZyb20ocHVibGljS2V5VWludDhBcnJheSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gb3BlbkJveChcbiAgICAgIGNpcGhlckJ5dGVzLFxuICAgICAgbm9uY2VCeXRlcyxcbiAgICAgIGNvbnZlcnRlZFB1YmxpY0tleSxcbiAgICAgIGNvbnZlcnRlZFByaXZhdGVLZXlcbiAgICApO1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlY29kZWQpLnRvU3RyaW5nKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKFxuICAgICAgZXJyb3IubWVzc2FnZS5tYXRjaChcbiAgICAgICAgL2JhZCBub25jZSBzaXplfG5vbmNlIG11c3QgYmUgYSBidWZmZXIgb2Ygc2l6ZSBjcnlwdG9fYm94X05PTkNFQllURVMvXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub25jZSB0byBiZSAyNCBieXRlcy5cIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIGRlY3J5cHRpb24uIElzIHRoaXMgdGhlIGZ1bGwgZW5jcnlwdGVkIG1lc3NhZ2U/XCJcbiAgICApO1xuICB9XG59O1xuXG5jb25zdCBnZXRLZXlGcm9tUGFzc3dvcmQgPSAoXG4gIHBhc3N3b3JkOiBzdHJpbmcsXG4gIHNhbHQ6IEJ1ZmZlcixcbiAgaXRlcmF0aW9uczogbnVtYmVyXG4pOiBCdWZmZXIgPT5cbiAgY3J5cHRvLnBia2RmMlN5bmMoXG4gICAgcGFzc3dvcmQsXG4gICAgc2FsdCxcbiAgICBpdGVyYXRpb25zLFxuICAgIFBCS0RGMl9LRVlMRU4sXG4gICAgUEJLREYyX0hBU0hfRlVOQ1RJT05cbiAgKTtcblxuZXhwb3J0IGludGVyZmFjZSBFbmNyeXB0ZWRQYXNzcGhyYXNlT2JqZWN0IHtcbiAgcmVhZG9ubHkgY2lwaGVyVGV4dDogc3RyaW5nO1xuICByZWFkb25seSBpdGVyYXRpb25zPzogbnVtYmVyO1xuICByZWFkb25seSBpdjogc3RyaW5nO1xuICByZWFkb25seSBzYWx0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRhZzogc3RyaW5nO1xuICByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IGVuY3J5cHRBRVMyNTZHQ01XaXRoUGFzc3dvcmQgPSAoXG4gIHBsYWluVGV4dDogc3RyaW5nLFxuICBwYXNzd29yZDogc3RyaW5nLFxuICBpdGVyYXRpb25zOiBudW1iZXIgPSBQQktERjJfSVRFUkFUSU9OU1xuKTogRW5jcnlwdGVkUGFzc3BocmFzZU9iamVjdCA9PiB7XG4gIGNvbnN0IElWX0JVRkZFUl9TSVpFID0gMTI7XG4gIGNvbnN0IFNBTFRfQlVGRkVSX1NJWkUgPSAxNjtcbiAgY29uc3QgaXYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoSVZfQlVGRkVSX1NJWkUpO1xuICBjb25zdCBzYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKFNBTFRfQlVGRkVSX1NJWkUpO1xuICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tUGFzc3dvcmQocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMpO1xuXG4gIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihcImFlcy0yNTYtZ2NtXCIsIGtleSwgaXYpO1xuICBjb25zdCBmaXJzdEJsb2NrID0gY2lwaGVyLnVwZGF0ZShwbGFpblRleHQsIFwidXRmOFwiKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbZmlyc3RCbG9jaywgY2lwaGVyLmZpbmFsKCldKTtcbiAgY29uc3QgdGFnID0gY2lwaGVyLmdldEF1dGhUYWcoKTtcblxuICByZXR1cm4ge1xuICAgIGl0ZXJhdGlvbnMsXG4gICAgY2lwaGVyVGV4dDogZW5jcnlwdGVkLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIGl2OiBpdi50b1N0cmluZyhcImhleFwiKSxcbiAgICBzYWx0OiBzYWx0LnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIHRhZzogdGFnLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIHZlcnNpb246IEVOQ1JZUFRJT05fVkVSU0lPTlxuICB9O1xufTtcblxuY29uc3QgZ2V0VGFnQnVmZmVyID0gKHRhZzogc3RyaW5nKTogQnVmZmVyID0+IHtcbiAgY29uc3QgVEFHX0JVRkZFUl9TSVpFID0gMTY7XG4gIGNvbnN0IHRhZ0J1ZmZlciA9IGhleFRvQnVmZmVyKHRhZywgXCJUYWdcIik7XG4gIGlmICh0YWdCdWZmZXIubGVuZ3RoICE9PSBUQUdfQlVGRkVSX1NJWkUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWcgbXVzdCBiZSAxNiBieXRlcy5cIik7XG4gIH1cblxuICByZXR1cm4gdGFnQnVmZmVyO1xufTtcblxuY29uc3QgZGVjcnlwdEFFUzI1NkdDTVdpdGhQYXNzd29yZCA9IChcbiAgZW5jcnlwdGVkUGFzc3BocmFzZTogRW5jcnlwdGVkUGFzc3BocmFzZU9iamVjdCxcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuKTogc3RyaW5nID0+IHtcbiAgY29uc3Qge1xuICAgIGl0ZXJhdGlvbnMgPSBQQktERjJfSVRFUkFUSU9OUyxcbiAgICBjaXBoZXJUZXh0LFxuICAgIGl2LFxuICAgIHNhbHQsXG4gICAgdGFnXG4gIH0gPSBlbmNyeXB0ZWRQYXNzcGhyYXNlO1xuXG4gIGNvbnN0IHRhZ0J1ZmZlciA9IGdldFRhZ0J1ZmZlcih0YWcpO1xuICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tUGFzc3dvcmQoXG4gICAgcGFzc3dvcmQsXG4gICAgaGV4VG9CdWZmZXIoc2FsdCwgXCJTYWx0XCIpLFxuICAgIGl0ZXJhdGlvbnNcbiAgKTtcblxuICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFxuICAgIFwiYWVzLTI1Ni1nY21cIixcbiAgICBrZXksXG4gICAgaGV4VG9CdWZmZXIoaXYsIFwiSVZcIilcbiAgKTtcbiAgZGVjaXBoZXIuc2V0QXV0aFRhZyh0YWdCdWZmZXIpO1xuICBjb25zdCBmaXJzdEJsb2NrID0gZGVjaXBoZXIudXBkYXRlKGhleFRvQnVmZmVyKGNpcGhlclRleHQsIFwiQ2lwaGVyIHRleHRcIikpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KFtmaXJzdEJsb2NrLCBkZWNpcGhlci5maW5hbCgpXSk7XG5cbiAgcmV0dXJuIGRlY3J5cHRlZC50b1N0cmluZygpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVuY3J5cHRQYXNzcGhyYXNlV2l0aFBhc3N3b3JkID0gZW5jcnlwdEFFUzI1NkdDTVdpdGhQYXNzd29yZDtcblxuZXhwb3J0IGNvbnN0IGRlY3J5cHRQYXNzcGhyYXNlV2l0aFBhc3N3b3JkID0gZGVjcnlwdEFFUzI1NkdDTVdpdGhQYXNzd29yZDtcbiJdfQ==